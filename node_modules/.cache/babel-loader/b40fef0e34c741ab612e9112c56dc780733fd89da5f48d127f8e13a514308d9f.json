{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = require(\"fast-equals\");\nvar _react = _interopRequireDefault(require(\"react\"));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n}\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.key), _react.default.Children.map(b, c => c?.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.props[\"data-grid\"]), _react.default.Children.map(b, c => c?.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = exports.fastRGLPropsEqual = require(\"./fastRGLPropsEqual\");\n\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if (child?.key == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      const key = subProps[j];\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${value} (${typeof value})`);\n      }\n    }\n    if (typeof item.i !== \"undefined\" && typeof item.i !== \"string\") {\n      throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${item.i} (${typeof item.i})`);\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;","map":{"version":3,"names":["Object","defineProperty","exports","value","bottom","childrenEqual","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","correctBounds","fastPositionEqual","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","resizeItemInDirection","setTopLeft","setTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","validateLayout","withLayoutItem","_fastEquals","require","_react","_interopRequireDefault","e","__esModule","default","isProduction","process","env","NODE_ENV","DEBUG","layout","max","bottomY","i","len","length","y","h","newLayout","Array","layoutItem","itemKey","cb","item","w","x","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","a","b","deepEqual","Children","map","c","key","props","left","top","width","height","l1","l2","cols","allowOverlap","compareWith","sorted","out","l","push","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","itemIndex","otherItem","fullLayout","compactV","compactH","Math","min","bounds","collidesWith","id","filter","isUserAction","preventCollision","log","String","oldX","oldY","movingUp","reverse","collisions","hasCollisions","collision","itemToMove","fakeItem","firstCollision","collisionNorth","collisionWest","undefined","newX","newY","num","constrainWidth","currentWidth","newWidth","containerWidth","constrainHeight","currentHeight","newHeight","constrainLeft","constrainTop","resizeNorth","currentSize","_ref","_containerWidth","resizeEast","_ref2","resizeWest","_ref3","resizeSouth","_ref4","resizeNorthEast","arguments","resizeNorthWest","resizeSouthEast","resizeSouthWest","ordinalResizeHandlerMap","n","ne","se","s","sw","nw","direction","newSize","ordinalHandler","_ref5","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","_ref6","slice","sort","initialLayout","children","forEach","child","exists","g","correctedLayout","contextName","subProps","isArray","Error","j","Number","isNaN","verticalCompact","console"],"sources":["/Users/isaacson/Projects/invester/node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = require(\"fast-equals\");\nvar _react = _interopRequireDefault(require(\"react\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.key), _react.default.Children.map(b, c => c?.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.props[\"data-grid\"]), _react.default.Children.map(b, c => c?.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = exports.fastRGLPropsEqual = require(\"./fastRGLPropsEqual\");\n\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if (child?.key == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      const key = subProps[j];\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${value} (${typeof value})`);\n      }\n    }\n    if (typeof item.i !== \"undefined\" && typeof item.i !== \"string\") {\n      throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${item.i} (${typeof item.i})`);\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,MAAM,GAAGA,MAAM;AACvBF,OAAO,CAACG,aAAa,GAAGA,aAAa;AACrCH,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjCJ,OAAO,CAACK,eAAe,GAAGA,eAAe;AACzCL,OAAO,CAACM,QAAQ,GAAGA,QAAQ;AAC3BN,OAAO,CAACO,OAAO,GAAGA,OAAO;AACzBP,OAAO,CAACQ,WAAW,GAAGA,WAAW;AACjCR,OAAO,CAACS,WAAW,GAAGA,WAAW;AACjCT,OAAO,CAACU,aAAa,GAAGA,aAAa;AACrCV,OAAO,CAACW,iBAAiB,GAAGA,iBAAiB;AAC7CX,OAAO,CAACY,iBAAiB,GAAG,KAAK,CAAC;AAClCZ,OAAO,CAACa,gBAAgB,GAAGA,gBAAgB;AAC3Cb,OAAO,CAACc,iBAAiB,GAAGA,iBAAiB;AAC7Cd,OAAO,CAACe,aAAa,GAAGA,aAAa;AACrCf,OAAO,CAACgB,UAAU,GAAGA,UAAU;AAC/BhB,OAAO,CAACiB,YAAY,GAAGA,YAAY;AACnCjB,OAAO,CAACkB,WAAW,GAAGA,WAAW;AACjClB,OAAO,CAACmB,4BAA4B,GAAGA,4BAA4B;AACnEnB,OAAO,CAACoB,IAAI,GAAG,KAAK,CAAC;AACrBpB,OAAO,CAACqB,IAAI,GAAGA,IAAI;AACnBrB,OAAO,CAACsB,qBAAqB,GAAGA,qBAAqB;AACrDtB,OAAO,CAACuB,UAAU,GAAGA,UAAU;AAC/BvB,OAAO,CAACwB,YAAY,GAAGA,YAAY;AACnCxB,OAAO,CAACyB,eAAe,GAAGA,eAAe;AACzCzB,OAAO,CAAC0B,uBAAuB,GAAGA,uBAAuB;AACzD1B,OAAO,CAAC2B,uBAAuB,GAAGA,uBAAuB;AACzD3B,OAAO,CAAC4B,6BAA6B,GAAGA,6BAA6B;AACrE5B,OAAO,CAAC6B,cAAc,GAAGA,cAAc;AACvC7B,OAAO,CAAC8B,cAAc,GAAGA,cAAc;AACvC,IAAIC,WAAW,GAAGC,OAAO,CAAC,aAAa,CAAC;AACxC,IAAIC,MAAM,GAAGC,sBAAsB,CAACF,OAAO,CAAC,OAAO,CAAC,CAAC;AACrD,SAASE,sBAAsBA,CAACC,CAAC,EAAE;EAAE,OAAOA,CAAC,IAAIA,CAAC,CAACC,UAAU,GAAGD,CAAC,GAAG;IAAEE,OAAO,EAAEF;EAAE,CAAC;AAAE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY;AAC1D,MAAMC,KAAK,GAAG,KAAK;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,SAASxC,MAAMA,CAACyC,MAAM,CAAC,cAAc,YAAY;EAC/C,IAAIC,GAAG,GAAG,CAAC;IACTC,OAAO;EACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGJ,MAAM,CAACK,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACjDD,OAAO,GAAGF,MAAM,CAACG,CAAC,CAAC,CAACG,CAAC,GAAGN,MAAM,CAACG,CAAC,CAAC,CAACI,CAAC;IACnC,IAAIL,OAAO,GAAGD,GAAG,EAAEA,GAAG,GAAGC,OAAO;EAClC;EACA,OAAOD,GAAG;AACZ;AACA,SAASxC,WAAWA,CAACuC,MAAM,CAAC,cAAc,YAAY;EACpD,MAAMQ,SAAS,GAAGC,KAAK,CAACT,MAAM,CAACK,MAAM,CAAC;EACtC,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}