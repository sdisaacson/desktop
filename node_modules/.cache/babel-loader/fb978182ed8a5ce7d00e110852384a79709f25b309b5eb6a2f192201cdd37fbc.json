{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    containerPadding,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x * (colWidth + marginX) = left - containerPaddingX\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","calcGridColWidth","calcGridItemPosition","calcGridItemWHPx","calcWH","calcXY","clamp","positionParams","margin","containerPadding","containerWidth","cols","gridUnits","colOrRowSize","marginPx","Number","isFinite","Math","round","max","x","y","w","h","state","rowHeight","colWidth","out","resizing","width","height","dragging","top","left","maxRows","handle","_w","_h","indexOf","num","lowerBound","upperBound","min"],"sources":["/Users/isaacson/Projects/invester/node_modules/react-grid-layout/build/calculateUtils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    containerPadding,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x * (colWidth + marginX) = left - containerPaddingX\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}