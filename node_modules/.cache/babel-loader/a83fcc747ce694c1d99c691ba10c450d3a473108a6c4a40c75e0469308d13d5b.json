{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.sortBreakpoints = sortBreakpoints;\nvar _utils = require(\"./utils\");\n/*:: import type { CompactType, Layout } from \"./utils\";*/\n/*:: export type Breakpoint = string;*/\n/*:: export type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";*/\n/*:: export type ResponsiveLayout<T: Breakpoint> = {\n  +[breakpoint: T]: Layout\n};*/\n// + indicates read-only\n/*:: export type Breakpoints<T: Breakpoint> = {\n  +[breakpoint: T]: number\n};*/\n/*:: export type OnLayoutChangeCallback = (\n  Layout,\n  { [key: Breakpoint]: Layout }\n) => void;*/\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints /*: Breakpoints<Breakpoint>*/, width /*: number*/) /*: Breakpoint*/{\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nfunction getColsFromBreakpoint(breakpoint /*: Breakpoint*/, cols /*: Breakpoints<Breakpoint>*/) /*: number*/{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts /*: ResponsiveLayout<Breakpoint>*/, breakpoints /*: Breakpoints<Breakpoint>*/, breakpoint /*: Breakpoint*/, lastBreakpoint /*: Breakpoint*/, cols /*: number*/, compactType /*: CompactType*/) /*: Layout*/{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints /*: Breakpoints<Breakpoint>*/) /*: Array<Breakpoint>*/{\n  const keys /*: Array<string>*/ = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","findOrGenerateResponsiveLayout","getBreakpointFromWidth","getColsFromBreakpoint","sortBreakpoints","_utils","require","breakpoints","width","sorted","matching","i","len","length","breakpointName","breakpoint","cols","Error","layouts","lastBreakpoint","compactType","cloneLayout","layout","breakpointsSorted","breakpointsAbove","slice","indexOf","b","compact","correctBounds","keys","sort","a"],"sources":["/Users/isaacson/Projects/invester/node_modules/react-grid-layout/build/responsiveUtils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.sortBreakpoints = sortBreakpoints;\nvar _utils = require(\"./utils\");\n/*:: import type { CompactType, Layout } from \"./utils\";*/\n/*:: export type Breakpoint = string;*/\n/*:: export type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";*/\n/*:: export type ResponsiveLayout<T: Breakpoint> = {\n  +[breakpoint: T]: Layout\n};*/\n// + indicates read-only\n/*:: export type Breakpoints<T: Breakpoint> = {\n  +[breakpoint: T]: number\n};*/\n/*:: export type OnLayoutChangeCallback = (\n  Layout,\n  { [key: Breakpoint]: Layout }\n) => void;*/\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints /*: Breakpoints<Breakpoint>*/, width /*: number*/) /*: Breakpoint*/{\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nfunction getColsFromBreakpoint(breakpoint /*: Breakpoint*/, cols /*: Breakpoints<Breakpoint>*/) /*: number*/{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts /*: ResponsiveLayout<Breakpoint>*/, breakpoints /*: Breakpoints<Breakpoint>*/, breakpoint /*: Breakpoint*/, lastBreakpoint /*: Breakpoint*/, cols /*: number*/, compactType /*: CompactType*/) /*: Layout*/{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints /*: Breakpoints<Breakpoint>*/) /*: Array<Breakpoint>*/{\n  const keys /*: Array<string>*/ = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}